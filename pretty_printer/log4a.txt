program sample29 ;
	var unused1 : integer ;
		UnusedArrayForTest : array [ NUMBER ] of char ;
	procedure gcmlcm ( m , n , gc , lc : integer ) ;
		var a , b , r : integer ;
	begin
		a := m ;
		b := n ;
		while b <> NUMBER do
		begin
			r := a - ( a div b ) * b ;
			a := b ;
			b := r 
		end ;
		gc := a ;
		lc := ( m div gc ) * n 
	end ;
	procedure abs ( a , b : integer ) ;
	begin
		if a < NUMBER then
			b := - a 
		else
			b:=a
	end ;
	procedure gcm ( a , b , gc : integer ) ;
		var lc , aa , bb : integer ;
	begin
		if ( a = NUMBER ) or ( b = NUMBER ) then
			gc := NUMBER 
		else
		begin
			call abs ( a , aa ) ;
			call abs ( b , bb ) ;
			call gcmlcm ( aa , bb , gc , lc ) 
		end 
	end ;
	procedure lcm ( a , b , lc : integer ) ;
		var gc , aa , bb : integer ;
	begin
		if ( a = NUMBER ) or ( b = NUMBER ) then
			lc := NUMBER 
		else
		begin
			call abs ( a , aa ) ;
			call abs ( b , bb ) ;
			call gcmlcm ( aa , bb , gc , lc ) 
		end 
	end ;
	var unusedchar : char ;
	procedure reduce ( a1 , a2 : integer ) ;
		var gc : integer ;
	begin
		if a1 = NUMBER then
		begin
			a2 := NUMBER ;
			return 
		end ;
		if a2 = NUMBER then
		begin
			a1 := NUMBER ;
			return 
		end ;
		if a2 < NUMBER then
		begin
			a1 := - a1 ;
			a2 := - a2 
		end ;
		call gcm ( a1 , a2 , gc ) ;
		a1 := a1 div gc ;
		a2 := a2 div gc 
	end ;
	procedure sum ( x1 , x2 , y1 , y2 : integer ) ;
		var lc , y11 : integer ;
	begin
		call lcm ( x2 , y2 , lc ) ;
		x1 := x1 * ( lc div x2 ) ;
		y11 := y1 * ( lc div y2 ) ;
		x1 := x1 + y11 ;
		x2 := lc ;
		call reduce ( x1 , x2 ) 
	end ;
	procedure sub ( x1 , x2 , y1 , y2 : integer ) ;
		var lc , y11 : integer ;
	begin
		call sum ( x1 , x2 , - y1 , y2 ) 
	end ;
	procedure mult ( x1 , x2 , y1 , y2 : integer ) ;
		var gc , y22 , y11 : integer ;
	begin
		call gcm ( x1 , y2 , gc ) ;
		x1 := x1 div gc ;
		y22 := y2 div gc ;
		call gcm ( x2 , y1 , gc ) ;
		x2 := x2 div gc ;
		y11 := y1 div gc ;
		x1 := x1 * y11 ;
		x2 := x2 * y22 ;
		call reduce ( x1 , x2 ) 
	end ;
	procedure divide ( x1 , x2 , y1 , y2 : integer ) ;
	begin
		call mult ( x1 , x2 , y2 , y1 ) 
	end ;
	var unusedarray : array [ NUMBER ] of char ;
	procedure printfinal ( a , b : integer ) ;
	begin
		if a = NUMBER then
			writeln ( 'STRING' , a ) 
		else if b = NUMBER then
			writeln ( 'STRING' , a ) 
		else
			writeln('STRING',a,'STRING',b)
	end ;
	procedure printtemp ( a , b : integer ) ;
	begin
		if a = NUMBER then
			writeln ( 'STRING' , a ) 
		else if b = NUMBER then
			writeln ( 'STRING' , a ) 
		else
			writeln('STRING',a,'STRING',b)
	end ;
	var x1 , x2 , y1 , y2 : integer ;
	var com : char ;
		endflag : boolean ;
begin
	writeln ( 'STRING' ) ;
	x1 := NUMBER ;
	x2 := NUMBER ;
	endflag := false ;
	while not endflag do
	begin
		writeln ( 'STRING' ) ;
		readln ( com , y1 ) ;
		y2 := NUMBER ;
		if ( com = 'STRING' ) or ( com = 'STRING' ) then
		begin
			x1 := y1 ;
			x2 := y2 
		end 
		else if com = 'STRING' then
			call sum ( x1 , x2 , y1 , y2 ) 
		else if com = 'STRING' then
			call sub ( x1 , x2 , y1 , y2 ) 
		else if com = 'STRING' then
			call mult ( x1 , x2 , y1 , y2 ) 
		else if com = 'STRING' then
			call divide ( x1 , x2 , y1 , y2 ) 
		else if ( com = 'STRING' ) or ( com = 'STRING' ) then
			endflag := true 
		else
		begin
			writeln ;
			writeln ( 'STRING' ) ;
			writeln ( 'STRING' ) ;
			writeln ( 'STRING' ) ;
			writeln ( 'STRING' ) ;
			writeln ( 'STRING' ) ;
			writeln ( 'STRING' ) ;
			writeln ( 'STRING' ) ;
			writeln 
		end ;
		if endflag then
			call printfinal ( x1 , x2 ) 
		else
			callprinttemp(x1,x2)
	end 
end . 
program sample29;
var unused1: integer;
UnusedArrayForTest: array [ NUMBER ] of char;
procedure gcmlcm (m, n, gc, lc: integer );
var a, b, r: integer;
begin
    a := m;
    b := n;
    while b <> NUMBER do begin
        r := a - (a div b) * b;
        a := b;
        b := r
    end;
    gc := a;
    lc := (m div gc) * n
end;
procedure abs (a, b: integer );
begin
    if a < NUMBER then 
    b := - a 
    else b := a
end;
procedure gcm (a, b, gc: integer );
var lc, aa, bb: integer;
begin
    if (a = NUMBER)or (b = NUMBER)then 
        gc := NUMBER 
        else begin
            call abs (a , aa);
            call abs (b , bb);
            call gcmlcm (aa , bb , gc , lc)
        end
    end;
    procedure lcm (a, b, lc: integer );
    var gc, aa, bb: integer;
    begin
        if (a = NUMBER)or (b = NUMBER)then 
            lc := NUMBER 
            else begin
                call abs (a , aa);
                call abs (b , bb);
                call gcmlcm (aa , bb , gc , lc)
            end
        end;
        var unusedchar: char;
        procedure reduce (a1, a2: integer );
        var gc: integer;
        begin
            if a1 = NUMBER then 
                begin
                    a2 := NUMBER;
                    return 
                end;
                if a2 = NUMBER then 
                begin
                    a1 := NUMBER;
                    return 
                end;
                if a2 < NUMBER then 
                begin
                    a1 := - a1;
                    a2 := - a2
                end;
                call gcm (a1 , a2 , gc);
                a1 := a1 div gc;
                a2 := a2 div gc
            end;
            procedure sum (x1, x2, y1, y2: integer );
            var lc, y11: integer;
            begin
                call lcm (x2 , y2 , lc);
                x1 := x1 * (lc div x2);
                y11 := y1 * (lc div y2);
                x1 := x1 + y11;
                x2 := lc;
                call reduce (x1 , x2)
            end;
            procedure sub (x1, x2, y1, y2: integer );
            var lc, y11: integer;
            begin
                call sum (x1 , x2 , - y1 , y2)
            end;
            procedure mult (x1, x2, y1, y2: integer );
            var gc, y22, y11: integer;
            begin
                call gcm (x1 , y2 , gc);
                x1 := x1 div gc;
                y22 := y2 div gc;
                call gcm (x2 , y1 , gc);
                x2 := x2 div gc;
                y11 := y1 div gc;
                x1 := x1 * y11;
                x2 := x2 * y22;
                call reduce (x1 , x2)
            end;
            procedure divide (x1, x2, y1, y2: integer );
            begin
                call mult (x1 , x2 , y2 , y1)
            end;
            var unusedarray: array [ NUMBER ] of char;
            procedure printfinal (a, b: integer );
            begin
                if a = NUMBER then 
                writeln ('STRING' , a)
                else if b = NUMBER then 
                    writeln ('STRING' , a)
                    else writeln ('STRING' , a , 'STRING' , b)
                end;
                procedure printtemp (a, b: integer );
                begin
                    if a = NUMBER then 
                        writeln ('STRING' , a)
                        else if b = NUMBER then 
                            writeln ('STRING' , a)
                            else writeln ('STRING' , a , 'STRING' , b)
                        end;
                        var x1, x2, y1, y2: integer;
                        var com: char;
                        endflag: boolean;
                        begin
                            writeln ('STRING');
                            x1 := NUMBER;
                            x2 := NUMBER;
                            endflag := false;
                            while not endflag do begin
                                writeln ('STRING');
                                readln (com , y1);
                                y2 := NUMBER;
                                if (com = 'STRING')or (com = 'STRING')then 
                                    begin
                                        x1 := y1;
                                        x2 := y2
                                    end
                                    else if com = 'STRING' then 
                                        call sum (x1 , x2 , y1 , y2)
                                        else if com = 'STRING' then 
                                            call sub (x1 , x2 , y1 , y2)
                                            else if com = 'STRING' then 
                                                call mult (x1 , x2 , y1 , y2)
                                                else if com = 'STRING' then 
                                                    call divide (x1 , x2 , y1 , y2)
                                                    else if (com = 'STRING')or (com = 'STRING')then 
                                                        endflag := true
                                                        else begin
                                                            writeln;
                                                            writeln ('STRING');
                                                            writeln ('STRING');
                                                            writeln ('STRING');
                                                            writeln ('STRING');
                                                            writeln ('STRING');
                                                            writeln ('STRING');
                                                            writeln ('STRING');
                                                            writeln
                                                        end;
                                                        if endflag then 
                                                            call printfinal (x1 , x2)
                                                            else call printtemp (x1 , x2)
                                                        end
                                                    end.